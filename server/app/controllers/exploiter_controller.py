import asyncio

from fastapi import APIRouter, HTTPException, WebSocket, WebSocketDisconnect

from schemas.exploiter_schema import ExploiterRequestBody
from services.exploiter_service import ExploiterService
from services.llm_service import LLMService
from services.websocket_service import manager

router = APIRouter(prefix="/exploiter", tags=["exploiter"])

llm_service = LLMService()
exploiter_service = ExploiterService()

@router.websocket("/ws/{ws_id}")
async def websocket_exploiter_status(websocket: WebSocket, ws_id: str):
    await manager.connect(websocket, ws_id)
    try:
        while True:
            await websocket.receive_text()
    except WebSocketDisconnect:
        manager.disconnect(websocket, ws_id)


@router.post("/run")
async def exploiter_run(body: ExploiterRequestBody):
    try:
        if body.ws_id:
            target_display = body.target
            # Try to strip parameter value for LLM generation message
            try:
                from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
                parsed_tgt = urlparse(body.target)
                qs_tgt = parse_qs(parsed_tgt.query)
                if body.params in qs_tgt:
                    qs_tgt[body.params] = ['']
                cleaned_query = urlencode(qs_tgt, doseq=True)
                target_display = urlunparse(parsed_tgt._replace(query=cleaned_query))
            except Exception:
                pass

            await manager.broadcast(body.ws_id, {"type": "info", "message": f"[*] Инициализация атаки на {target_display}..."})
            await manager.broadcast(body.ws_id, {"type": "info", "message": f"[*] Генерация LLM payload'ов для {body.vuln_type}..."})

        # Clean the URL that goes to the LLM so it doesn't get confused by ZAP's payload
        target_for_llm = body.target
        try:
            from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
            parsed_llm = urlparse(body.target)
            qs_llm = parse_qs(parsed_llm.query)
            if body.params in qs_llm:
                qs_llm[body.params] = ['']
            cleaned_query_llm = urlencode(qs_llm, doseq=True)
            target_for_llm = urlunparse(parsed_llm._replace(query=cleaned_query_llm))
        except Exception:
            pass

        payloads_task = asyncio.create_task(
            llm_service.ask_for_payloads(target_for_llm, body.vuln_type, body.params)
        )

        msg = f"[+] Используем предоставленные cookies для авторизации..."
        print(msg)
        if body.ws_id: await manager.broadcast(body.ws_id, {"type": "info", "message": msg})

        cookies = body.cookies

        payloads = await payloads_task
        if not payloads:
            msg = "LLM не вернул ни одного payload-а."
            if body.ws_id: await manager.broadcast(body.ws_id, {"type": "failed", "message": msg})
            return {
                "status": "failed",
                "message": msg,
                "tried_payloads": []
            }

        msg = f"[+] Получено {len(payloads)} ответных payload'ов от ИИ"
        print(msg)
        if body.ws_id: await manager.broadcast(body.ws_id, {"type": "info", "message": msg})

        tried_payloads = []

        for payload in payloads:
            tried_payloads.append(payload)
            if body.ws_id: await manager.broadcast(body.ws_id, {"type": "attack", "payload": payload, "status": "testing"})

            success, message, curl_command = await exploiter_service.try_exploit(
                vuln_type=body.vuln_type,
                url=body.target,
                method=body.method,
                param=body.params,
                data={"payloads": payload},
                cookies=cookies,
                ws_id=body.ws_id
            )
            print(message)
            if success:
                if body.ws_id: await manager.broadcast(body.ws_id, {"type": "success", "message": message, "payload": payload})
                return {
                    "status": "confirmed",
                    "vuln_type": body.vuln_type,
                    "target": body.target,
                    "parameter": body.params,
                    "working_payload": payload,
                    "tried_payloads": tried_payloads,
                    "proof": message,
                    "curl": curl_command,
                    "message": "Уязвимость успешно подтверждена и эксплуатирована!"
                }
            else:
                 if body.ws_id: await manager.broadcast(body.ws_id, {"type": "failed", "message": message, "payload": payload})

        return {
            "status": "potential",
            "message": "Ни один payload не сработал. Возможно, нужна ручная проверка.",
            "tried_payloads": payloads[:10]
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ошибка при эксплуатации: {str(e)}")
